/*! (c) Andrea Giammarchi - ISC */
var saferPass=function(e){"use strict";var t=Function.call,r=t.bind(t.bind),n=r(t,t.apply);t=r(t,t);const{defineProperty:o,getPrototypeOf:s,getOwnPropertyDescriptor:c,getOwnPropertyNames:a,getOwnPropertySymbols:i,hasOwnProperty:p}=Object,y=(e,t)=>{o(e,t,{enumerable:!0,value:!1})};var u=e=>{const r=e,n=[],u=[];do{a(e).concat(i(e)).forEach(t=>{n.includes(t)||(n.push(t),u.push(c(e,t)))})}while(e=s(e));return n.forEach((e,n)=>{o(r,e,(e=>(y(e,"configurable"),t(p,e,"writable")&&y(e,"writable"),e))(u[n]))}),r},l=e=>(u(e.prototype),u(e));const{freeze:h,setPrototypeOf:d}=Object,{reject:f,resolve:m}=Promise;class v extends Promise{static reject(e){return t(f,v,P(e))}static resolve(e){return t(m,v,P(e))}constructor(e){h(super(e))}}const{prototype:w,reject:g,resolve:b}=v,P=e=>"object"==typeof e&&null!==e&&"then"in e&&!(e instanceof v)?d(e,w):e;l(v),h(v),h(w);const{freeze:O,defineProperty:j,getOwnPropertyNames:E,getPrototypeOf:k}=Object,K=(e,t)=>!/^(?:caller|callee|arguments)$/.test(t)&&"function"==typeof e[t]&&"constructor"!==t,{subtle:S}=crypto,x={},z={};E(k(crypto)).forEach(e=>{K(crypto,e)&&j(x,e,{enumerable:!0,value:r(crypto[e],crypto)})}),E(k(S)).forEach(e=>{if(K(S,e)){const t=S[e];j(z,e,{enumerable:!0,value(){return b(n(t,S,arguments))}})}});var C=O(j(x,"subtle",{enumerable:!0,value:O(z)}));const{freeze:A}=Object,{fromCharCode:B}=String,{charCodeAt:D}="",{map:$}=[],F=Uint8Array,N=e=>n(B,null,e),T=e=>t($,e,e=>t(D,e,0));class V extends F{static from(e){return super.from("string"==typeof e?T(e):e)}constructor(e=16){super(e);const t=C.getRandomValues(new F(e));for(let r=0;r<e;r++)this[r]=t[r]}toString(){return N(this)}}l(V),A(V),A(V.prototype);const{encode:H,decode:I}=((e,r)=>{const{encode:n}=e.prototype,{decode:o}=r.prototype;return{encode:r=>t(n,new e,r),decode:(e,n,s)=>t(o,new r(n||"utf-8",s||{}),e)}})(TextEncoder,TextDecoder),M=256,R="AES-CBC",U=new WeakMap,W=r(U.get,U),q=r(U.set,U),{subtle:G}=C;class J{static unserialize(e,t,r){const{data:n,iv:o,str:s}=e;return new J(t,V.from(o),r).decrypt(n,s)}constructor(e,t=new V,r=`${N(t)}${B(e.length)}`){"string"==typeof e&&(e=H(e)),"string"==typeof r&&(r=H(r));q(A(this),new v(n=>{G.importKey("raw",e,{name:"PBKDF2"},!1,["deriveBits","deriveKey"]).then(e=>G.deriveKey({name:"PBKDF2",salt:r,iterations:8192,hash:`SHA-${M}`},e,{name:R,length:M},!0,["encrypt","decrypt"])).then(e=>{G.exportKey("jwk",e).then(r=>n({iv:t,key:e,jwk:r}))})}))}decrypt(e,t=!1){const r=W(this).then(({iv:t,key:r})=>G.decrypt({name:R,iv:t},r,"string"==typeof e?new F(T(e)):e));return(t?r.then(I):r).catch(()=>g(new Error("unable to decrypt")))}encrypt(e,t=!1){const r=W(this).then(({iv:t,key:r})=>G.encrypt({name:R,iv:t},r,"string"==typeof e?H(e):e));return(t?r.then(e=>N(new F(e))):r).catch(()=>g(new Error("unable to encrypt")))}serialize(e){return W(this).then(({iv:t})=>this.encrypt(e,!0).then(r=>({data:r,iv:t.toString(),str:"string"==typeof e})))}}return l(J),A(J),A(J.prototype),e.IV=V,e.Pass=J,e}({});
