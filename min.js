/*! (c) Andrea Giammarchi - ISC */
var saferPass=function(e){"use strict";var t=Function.call,r=t.bind(t.bind),n=r(t,t.apply);t=r(t,t);const{defineProperty:o,getPrototypeOf:s,getOwnPropertyDescriptor:c,getOwnPropertyNames:a,getOwnPropertySymbols:i,hasOwnProperty:p}=Object,y=(e,t)=>{o(e,t,{enumerable:!0,value:!1})};var u=e=>{const r=e,n=[],u=[];do{a(e).concat(i(e)).forEach(t=>{n.includes(t)||(n.push(t),u.push(c(e,t)))})}while(e=s(e));return n.forEach((e,n)=>{o(r,e,(e=>(y(e,"configurable"),t(p,e,"writable")&&y(e,"writable"),e))(u[n]))}),r},l=e=>(u(e.prototype),u(e));const{freeze:d,setPrototypeOf:f}=Object,{reject:h,resolve:m}=Promise;class v extends Promise{static reject(e){return t(h,v,P(e))}static resolve(e){return t(m,v,P(e))}constructor(e){d(super(e))}}const{prototype:w,reject:b,resolve:g}=v,P=e=>"object"==typeof e&&null!==e&&"then"in e&&!(e instanceof v)?f(e,w):e;l(v),d(v),d(w);const{freeze:O,defineProperty:j,getOwnPropertyNames:E,getPrototypeOf:k}=Object,K=(e,t)=>!/^(?:caller|callee|arguments)$/.test(t)&&"function"==typeof e[t]&&"constructor"!==t,{subtle:S}=crypto,x={},z={};E(k(crypto)).forEach(e=>{K(crypto,e)&&j(x,e,{enumerable:!0,value:r(crypto[e],crypto)})}),E(k(S)).forEach(e=>{if(K(S,e)){const t=S[e];j(z,e,{enumerable:!0,value(){return g(n(t,S,arguments))}})}});var C=O(j(x,"subtle",{enumerable:!0,value:O(z)}));const{freeze:A}=Object,{fromCharCode:B}=String,{charCodeAt:D}="",{map:F}=[],N=Uint8Array,T=e=>n(B,null,e),V=e=>t(F,e,e=>t(D,e,0));class $ extends N{static from(e){return super.from("string"==typeof e?V(e):e)}constructor(e=16){super(e);const t=C.getRandomValues(new N(e));for(let r=0;r<e;r++)this[r]=t[r]}toString(){return T(this)}}l($),A($),A($.prototype);const{encode:H,decode:I}=((e,r)=>{const{encode:n}=e.prototype,{decode:o}=r.prototype;return{encode:r=>t(n,new e,r),decode:(e,n,s)=>t(o,new r(n||"utf-8",s||{}),e)}})(TextEncoder,TextDecoder),M=256,R="AES-CBC",U=new WeakMap,W=r(U.get,U),q=r(U.set,U),{subtle:G}=C;class J{static unserialize(e,t,r){const{data:n,iv:o,str:s}=e;return new J(t,r,$.from(o)).decrypt(n,s)}constructor(e,t=R+M,r=new $){"string"==typeof e&&(e=H(e)),"string"==typeof t&&(t=H(t));q(A(this),new v(n=>{G.importKey("raw",e,{name:"PBKDF2"},!1,["deriveBits","deriveKey"]).then(e=>G.deriveKey({name:"PBKDF2",salt:t,iterations:8192,hash:`SHA-${M}`},e,{name:R,length:M},!0,["encrypt","decrypt"])).then(e=>{G.exportKey("jwk",e).then(t=>n({iv:r,key:e,jwk:t}))})}))}decrypt(e,t=!1){const r=W(this).then(({iv:t,key:r})=>G.decrypt({name:R,iv:t},r,"string"==typeof e?new N(V(e)):e));return(t?r.then(I):r).catch(()=>b(new Error("unable to decrypt")))}encrypt(e,t=!1){const r=W(this).then(({iv:t,key:r})=>G.encrypt({name:R,iv:t},r,"string"==typeof e?H(e):e));return(t?r.then(e=>T(new N(e))):r).catch(()=>b(new Error("unable to encrypt")))}serialize(e){return W(this).then(({iv:t})=>this.encrypt(e,!0).then(r=>({data:r,iv:t.toString(),str:"string"==typeof e})))}}return l(J),A(J),A(J.prototype),e.IV=$,e.Pass=J,e}({});
