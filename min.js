/*! (c) Andrea Giammarchi - ISC */
var saferPass=function(e){"use strict";var t=Function.call,r=t.bind(t.bind),n=r(t,t.apply);t=r(t,t);const{defineProperty:o,getPrototypeOf:s,getOwnPropertyDescriptor:c,getOwnPropertyNames:a,getOwnPropertySymbols:i,hasOwnProperty:p}=Object,{concat:y,forEach:u,includes:l,push:d}=[],f=(e,t)=>{o(e,t,{enumerable:!0,value:!1})};var h=e=>{const r=e,n=[],h=[];do{t(u,t(y,a(e),i(e)),r=>{t(l,n,r)||(t(d,n,r),t(d,h,c(e,r)))})}while(e=s(e));return t(u,n,(e,n)=>{o(r,e,(e=>(f(e,"configurable"),t(p,e,"writable")&&f(e,"writable"),e))(h[n]))}),r},m=e=>(h(e.prototype),h(e));const{freeze:v,setPrototypeOf:w}=Object,{reject:b,resolve:g}=Promise;class P extends Promise{static reject(e){return t(b,P,k(e))}static resolve(e){return t(g,P,k(e))}constructor(e){v(super(e))}}const{prototype:O,reject:j,resolve:E}=P,k=e=>"object"==typeof e&&null!==e&&"then"in e&&!(e instanceof P)?w(e,O):e;m(P),v(P),v(O);const{freeze:K,defineProperty:S,getOwnPropertyNames:x,getPrototypeOf:z}=Object,C=(e,t)=>!/^(?:caller|callee|arguments)$/.test(t)&&"function"==typeof e[t]&&"constructor"!==t,{subtle:A}=crypto,B={},D={};x(z(crypto)).forEach(e=>{C(crypto,e)&&S(B,e,{enumerable:!0,value:r(crypto[e],crypto)})}),x(z(A)).forEach(e=>{if(C(A,e)){const t=A[e];S(D,e,{enumerable:!0,value(){return E(n(t,A,arguments))}})}});var F=K(S(B,"subtle",{enumerable:!0,value:K(D)}));const{freeze:N}=Object,{fromCharCode:T}=String,{charCodeAt:V}="",{map:$}=[],H=Uint8Array,I=e=>n(T,null,e),M=e=>t($,e,e=>t(V,e,0));class R extends H{static from(e){return super.from("string"==typeof e?M(e):e)}constructor(e=16){super(e);const t=F.getRandomValues(new H(e));for(let r=0;r<e;r++)this[r]=t[r]}toString(){return I(this)}}m(R),N(R),N(R.prototype);const{encode:U,decode:W}=((e,r)=>{const{encode:n}=e.prototype,{decode:o}=r.prototype;return{encode:r=>t(n,new e,r),decode:(e,n,s)=>t(o,new r(n||"utf-8",s||{}),e)}})(TextEncoder,TextDecoder),q=256,G="AES-CBC",J=new WeakMap,L=r(J.get,J),Q=r(J.set,J),{subtle:X}=F;class Y{static unserialize(e,t,r){const{data:n,iv:o,str:s}=e;return new Y(t,r,R.from(o)).decrypt(n,s)}constructor(e,t=G+q,r=new R){"string"==typeof e&&(e=U(e)),"string"==typeof t&&(t=U(t));Q(N(this),new P(n=>{X.importKey("raw",e,{name:"PBKDF2"},!1,["deriveBits","deriveKey"]).then(e=>X.deriveKey({name:"PBKDF2",salt:t,iterations:8192,hash:`SHA-${q}`},e,{name:G,length:q},!0,["encrypt","decrypt"])).then(e=>{X.exportKey("jwk",e).then(t=>n({iv:r,key:e,jwk:t}))})}))}decrypt(e,t=!1){const r=L(this).then(({iv:t,key:r})=>X.decrypt({name:G,iv:t},r,"string"==typeof e?new H(M(e)):e));return(t?r.then(W):r).catch(()=>j(new Error("unable to decrypt")))}encrypt(e,t=!1){const r=L(this).then(({iv:t,key:r})=>X.encrypt({name:G,iv:t},r,"string"==typeof e?U(e):e));return(t?r.then(e=>I(new H(e))):r).catch(()=>j(new Error("unable to encrypt")))}serialize(e){return L(this).then(({iv:t})=>this.encrypt(e,!0).then(r=>({data:r,iv:t.toString(),str:"string"==typeof e})))}}return m(Y),N(Y),N(Y.prototype),e.IV=R,e.Pass=Y,e}({});
