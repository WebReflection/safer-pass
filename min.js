/*! (c) Andrea Giammarchi - ISC */
var saferPass=function(e){"use strict";var t=Function.call,r=t.bind(t.bind),n=r(t,t.apply);t=r(t,t);const{freeze:o,setPrototypeOf:c}=Object,{prototype:s,reject:a,resolve:i}=Promise,{catch:p,then:y}=s;class u extends Promise{static reject(e){return t(a,u,f(e))}static resolve(e){return t(i,u,f(e))}constructor(e){o(super(e))}catch(){return n(p,this,arguments)}then(){return n(y,this,arguments)}}const{prototype:l,reject:h,resolve:d}=u,f=e=>"object"==typeof e&&null!==e&&"then"in e&&!(e instanceof u)?c(e,l):e;o(u),o(l);const{freeze:v,defineProperty:m,getOwnPropertyNames:g,getPrototypeOf:w}=Object,b=(e,t)=>!/^(?:caller|callee|arguments)$/.test(t)&&"function"==typeof e[t]&&"constructor"!==t,{subtle:P}=crypto,j={},k={};g(w(crypto)).forEach(e=>{b(crypto,e)&&m(j,e,{enumerable:!0,value:r(crypto[e],crypto)})}),g(w(P)).forEach(e=>{if(b(P,e)){const t=P[e];m(k,e,{enumerable:!0,value(){return d(n(t,P,arguments))}})}});var E=v(m(j,"subtle",{enumerable:!0,value:v(k)}));const{freeze:K}=Object,{fromCharCode:O}=String,{charCodeAt:x}="",{map:z}=[],C=Uint8Array,S=e=>n(O,null,e),A=e=>t(z,e,e=>t(x,e,0));class B extends C{static from(e){return super.from("string"==typeof e?A(e):e)}constructor(e=16){super(e);const t=E.getRandomValues(new C(e));for(let r=0;r<e;r++)this[r]=t[r]}toString(){return S(this)}}K(B),K(B.prototype);const{encode:$,decode:D}=((e,r)=>{const{encode:n}=e.prototype,{decode:o}=r.prototype;return{encode:r=>t(n,new e,r),decode:(e,n,c)=>t(o,new r(n||"utf-8",c||{}),e)}})(TextEncoder,TextDecoder),F=256,T="AES-CBC",V=new WeakMap,H=r(V.get,V),I=r(V.set,V),{subtle:M}=E;class N{constructor(e,t=new B,r=`${S(t)}${O(e.length)}`){"string"==typeof e&&(e=$(e)),"string"==typeof r&&(r=$(r));I(K(this),new u(n=>{M.importKey("raw",e,{name:"PBKDF2"},!1,["deriveBits","deriveKey"]).then(e=>M.deriveKey({name:"PBKDF2",salt:r,iterations:8192,hash:`SHA-${F}`},e,{name:T,length:F},!0,["encrypt","decrypt"])).then(e=>{M.exportKey("jwk",e).then(r=>n({iv:t,key:e,jwk:r}))})}))}decrypt(e,t=!1){const r=H(this).then(({iv:t,key:r})=>M.decrypt({name:T,iv:t},r,"string"==typeof e?new C(A(e)):e));return(t?r.then(D):r).catch(()=>h(new Error("unable to decrypt")))}encrypt(e,t=!1){const r=H(this).then(({iv:t,key:r})=>M.encrypt({name:T,iv:t},r,"string"==typeof e?$(e):e));return(t?r.then(e=>S(new C(e))):r).catch(()=>h(new Error("unable to encrypt")))}serialize(e){return H(this).then(({iv:t})=>this.encrypt(e,!0).then(r=>({data:r,iv:t.toString(),str:"string"==typeof e})))}static unserialize(e,t,r){const{data:n,iv:o,str:c}=e;return new N(t,B.from(o),r).decrypt(n,c)}}return K(N),K(N.prototype),e.IV=B,e.Pass=N,e}({});
