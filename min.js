/*! (c) Andrea Giammarchi - ISC */
var saferPass=function(e){"use strict";var t=Function.call,r=t.bind(t.bind),n=r(t,t.apply);t=r(t,t);const{defineProperty:o,getPrototypeOf:s,getOwnPropertyDescriptor:c,getOwnPropertyNames:a,getOwnPropertySymbols:i,hasOwnProperty:p}=Object,y=(e,t)=>{o(e,t,{enumerable:!0,value:!1})};var u=e=>{const r=e,n=[],u=[];do{a(e).concat(i(e)).forEach(t=>{n.includes(t)||(n.push(t),u.push(c(e,t)))})}while(e=s(e));return n.forEach((e,n)=>{o(r,e,(e=>(y(e,"configurable"),t(p,e,"writable")&&y(e,"writable"),e))(u[n]))}),r},l=e=>(u(e.prototype),u(e));const{freeze:h,setPrototypeOf:f}=Object,{reject:d,resolve:g}=Promise;class m extends Promise{static reject(e){return t(d,m,P(e))}static resolve(e){return t(g,m,P(e))}constructor(e){h(super(e))}}const{prototype:v,reject:w,resolve:b}=m,P=e=>"object"==typeof e&&null!==e&&"then"in e&&!(e instanceof m)?f(e,v):e;l(m),h(m),h(v);const{freeze:O,defineProperty:j,getOwnPropertyNames:E,getPrototypeOf:k}=Object,K=(e,t)=>!/^(?:caller|callee|arguments)$/.test(t)&&"function"==typeof e[t]&&"constructor"!==t,{subtle:S}=crypto,x={},z={};E(k(crypto)).forEach(e=>{K(crypto,e)&&j(x,e,{enumerable:!0,value:r(crypto[e],crypto)})}),E(k(S)).forEach(e=>{if(K(S,e)){const t=S[e];j(z,e,{enumerable:!0,value(){return b(n(t,S,arguments))}})}});var C=O(j(x,"subtle",{enumerable:!0,value:O(z)}));const{freeze:A}=Object,{fromCharCode:B}=String,{charCodeAt:D}="",{map:F}=[],N=Uint8Array,T=(e,t,r)=>e<t?r[e]:B(e),V=e=>n(B,null,e),$=e=>t(F,e,e=>t(D,e,0)),H=(e,t)=>{const r=e.length,n=t.length,o=r<n?n:r;let s="";for(let c=0;c<o;c++)s=s+T(c,r,e)+T(c,n,t);return s};class I extends N{static from(e){return super.from("string"==typeof e?$(e):e)}constructor(e=16){super(e);const t=C.getRandomValues(new N(e));for(let r=0;r<e;r++)this[r]=t[r]}toString(){return V(this)}}l(I),A(I),A(I.prototype);const{encode:M,decode:R}=((e,r)=>{const{encode:n}=e.prototype,{decode:o}=r.prototype;return{encode:r=>t(n,new e,r),decode:(e,n,s)=>t(o,new r(n||"utf-8",s||{}),e)}})(TextEncoder,TextDecoder),U=256,W="AES-CBC",q=new WeakMap,G=r(q.get,q),J=r(q.set,q),{subtle:L}=C;class Q{static unserialize(e,t,r){const{data:n,iv:o,str:s}=e;return new Q(t,I.from(o),r).decrypt(n,s)}constructor(e,t=new I,r=H(V(t),e)){"string"==typeof e&&(e=M(e)),"string"==typeof r&&(r=M(r));J(A(this),new m(n=>{L.importKey("raw",e,{name:"PBKDF2"},!1,["deriveBits","deriveKey"]).then(e=>L.deriveKey({name:"PBKDF2",salt:r,iterations:8192,hash:`SHA-${U}`},e,{name:W,length:U},!0,["encrypt","decrypt"])).then(e=>{L.exportKey("jwk",e).then(r=>n({iv:t,key:e,jwk:r}))})}))}decrypt(e,t=!1){const r=G(this).then(({iv:t,key:r})=>L.decrypt({name:W,iv:t},r,"string"==typeof e?new N($(e)):e));return(t?r.then(R):r).catch(()=>w(new Error("unable to decrypt")))}encrypt(e,t=!1){const r=G(this).then(({iv:t,key:r})=>L.encrypt({name:W,iv:t},r,"string"==typeof e?M(e):e));return(t?r.then(e=>V(new N(e))):r).catch(()=>w(new Error("unable to encrypt")))}serialize(e){return G(this).then(({iv:t})=>this.encrypt(e,!0).then(r=>({data:r,iv:t.toString(),str:"string"==typeof e})))}}return l(Q),A(Q),A(Q.prototype),e.IV=I,e.Pass=Q,e}({});
